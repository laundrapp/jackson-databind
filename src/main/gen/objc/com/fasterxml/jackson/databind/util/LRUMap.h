//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Salton/Documents/Projects/jackson-databind/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComFasterxmlJacksonDatabindUtilLRUMap")
#ifdef RESTRICT_ComFasterxmlJacksonDatabindUtilLRUMap
#define INCLUDE_ALL_ComFasterxmlJacksonDatabindUtilLRUMap 0
#else
#define INCLUDE_ALL_ComFasterxmlJacksonDatabindUtilLRUMap 1
#endif
#undef RESTRICT_ComFasterxmlJacksonDatabindUtilLRUMap

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComFasterxmlJacksonDatabindUtilLRUMap_) && (INCLUDE_ALL_ComFasterxmlJacksonDatabindUtilLRUMap || defined(INCLUDE_ComFasterxmlJacksonDatabindUtilLRUMap))
#define ComFasterxmlJacksonDatabindUtilLRUMap_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class JavaUtilConcurrentConcurrentHashMap;

/*!
 @brief Helper for simple bounded maps used for reusing lookup values.
 <p>
  Note that serialization behavior is such that contents are NOT serialized,
  on assumption that all use cases are for caching where persistence
  does not make sense. The only thing serialized is the cache size of Map.
 <p>
  NOTE: since version 2.4.2, this is <b>NOT</b> an LRU-based at all; reason
  being that it is not possible to use JDK components that do LRU _AND_ perform
  well wrt synchronization on multi-core systems. So we choose efficient synchronization
  over potentially more efficient handling of entries.
 <p>
  And yes, there are efficient LRU implementations such as 
 <a href="https://code.google.com/p/concurrentlinkedhashmap/">concurrentlinkedhashmap</a>;
  but at this point we really try to keep external deps to minimum. But perhaps
  a shaded variant may be used one day.
 */
@interface ComFasterxmlJacksonDatabindUtilLRUMap : NSObject < JavaIoSerializable > {
 @public
  jint _maxEntries_;
  JavaUtilConcurrentConcurrentHashMap *_map_;
  /*!
   @brief Ugly hack, to work through the requirement that _value is indeed final,
  and that JDK serialization won't call ctor(s) if Serializable is implemented.
   @since 2.1
   */
  jint _jdkSerializeMaxEntries_;
}

#pragma mark Public

- (instancetype __nonnull)initWithInt:(jint)initialEntries
                              withInt:(jint)maxEntries;

- (void)clear;

- (id)getWithId:(id)key;

- (id)putWithId:(id)key
         withId:(id)value;

/*!
 @since 2.5
 */
- (id)putIfAbsentWithId:(id)key
                 withId:(id)value;

- (jint)size;

#pragma mark Protected

- (id)readResolve;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComFasterxmlJacksonDatabindUtilLRUMap)

J2OBJC_FIELD_SETTER(ComFasterxmlJacksonDatabindUtilLRUMap, _map_, JavaUtilConcurrentConcurrentHashMap *)

FOUNDATION_EXPORT void ComFasterxmlJacksonDatabindUtilLRUMap_initWithInt_withInt_(ComFasterxmlJacksonDatabindUtilLRUMap *self, jint initialEntries, jint maxEntries);

FOUNDATION_EXPORT ComFasterxmlJacksonDatabindUtilLRUMap *new_ComFasterxmlJacksonDatabindUtilLRUMap_initWithInt_withInt_(jint initialEntries, jint maxEntries) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComFasterxmlJacksonDatabindUtilLRUMap *create_ComFasterxmlJacksonDatabindUtilLRUMap_initWithInt_withInt_(jint initialEntries, jint maxEntries);

J2OBJC_TYPE_LITERAL_HEADER(ComFasterxmlJacksonDatabindUtilLRUMap)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_ComFasterxmlJacksonDatabindUtilLRUMap")
