//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Salton/Documents/Projects/jackson-databind/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComFasterxmlJacksonDatabindJsonDeserializer")
#ifdef RESTRICT_ComFasterxmlJacksonDatabindJsonDeserializer
#define INCLUDE_ALL_ComFasterxmlJacksonDatabindJsonDeserializer 0
#else
#define INCLUDE_ALL_ComFasterxmlJacksonDatabindJsonDeserializer 1
#endif
#undef RESTRICT_ComFasterxmlJacksonDatabindJsonDeserializer
#ifdef INCLUDE_ComFasterxmlJacksonDatabindJsonDeserializer_None
#define INCLUDE_ComFasterxmlJacksonDatabindJsonDeserializer 1
#endif

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComFasterxmlJacksonDatabindJsonDeserializer_) && (INCLUDE_ALL_ComFasterxmlJacksonDatabindJsonDeserializer || defined(INCLUDE_ComFasterxmlJacksonDatabindJsonDeserializer))
#define ComFasterxmlJacksonDatabindJsonDeserializer_

#define RESTRICT_ComFasterxmlJacksonDatabindDeserNullValueProvider 1
#define INCLUDE_ComFasterxmlJacksonDatabindDeserNullValueProvider 1
#include "com/fasterxml/jackson/databind/deser/NullValueProvider.h"

@class ComFasterxmlJacksonCoreJsonParser;
@class ComFasterxmlJacksonDatabindDeserImplObjectIdReader;
@class ComFasterxmlJacksonDatabindDeserSettableBeanProperty;
@class ComFasterxmlJacksonDatabindDeserializationConfig;
@class ComFasterxmlJacksonDatabindDeserializationContext;
@class ComFasterxmlJacksonDatabindJsontypeTypeDeserializer;
@class ComFasterxmlJacksonDatabindUtilAccessPattern;
@class ComFasterxmlJacksonDatabindUtilNameTransformer;
@class IOSClass;
@class JavaLangBoolean;
@protocol JavaUtilCollection;

/*!
 @brief Abstract class that defines API used by <code>ObjectMapper</code> (and
  other chained <code>JsonDeserializer</code>s too) to deserialize Objects of
  arbitrary types from JSON, using provided <code>JsonParser</code>.
 <p>
  Custom deserializers should usually not directly extend this class,
  but instead extend <code>com.fasterxml.jackson.databind.deser.std.StdDeserializer</code>
  (or its subtypes like <code>com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer</code>).
 <p>
  If deserializer is an aggregate one -- meaning it delegates handling of some
  of its contents by using other deserializer(s) -- it typically also needs
  to implement <code>com.fasterxml.jackson.databind.deser.ResolvableDeserializer</code>,
  which can locate dependant deserializers. This is important to allow dynamic
  overrides of deserializers; separate call interface is needed to separate
  resolution of dependant deserializers (which may have cyclic link back
  to deserializer itself, directly or indirectly).
 <p>
  In addition, to support per-property annotations (to configure aspects
  of deserialization on per-property basis), deserializers may want
  to implement 
 <code>com.fasterxml.jackson.databind.deser.ContextualDeserializer</code>,
  which allows specialization of deserializers: call to 
 <code>com.fasterxml.jackson.databind.deser.ContextualDeserializer</code>
  is passed information on property, and can create a newly configured
  deserializer for handling that particular property.
 <p>
  If both 
 <code>com.fasterxml.jackson.databind.deser.ResolvableDeserializer</code> and 
 <code>com.fasterxml.jackson.databind.deser.ContextualDeserializer</code>
  are implemented, resolution of deserializers occurs before
  contextualization.
 */
@interface ComFasterxmlJacksonDatabindJsonDeserializer : NSObject < ComFasterxmlJacksonDatabindDeserNullValueProvider >

#pragma mark Public

- (instancetype __nonnull)init;

/*!
 @brief Method that can be called to ask implementation to deserialize
  JSON content into the value type this serializer handles.
 Returned instance is to be constructed by method itself.
 <p>
  Pre-condition for this method is that the parser points to the
  first event that is part of value to deserializer (and which 
  is never JSON 'null' literal, more on this below): for simple
  types it may be the only value; and for structured types the
  Object start marker or a FIELD_NAME. 
 </p>
  <p>
  The two possible input conditions for structured types result
  from polymorphism via fields. In the ordinary case, Jackson
  calls this method when it has encountered an OBJECT_START,
  and the method implementation must advance to the next token to
  see the first field name. If the application configures
  polymorphism via a field, then the object looks like the following.
   @code

       {
           "@@class": "class name",
           ...
       }  
  
@endcode
   Jackson consumes the two tokens (the <tt>@@class</tt> field name
   and its value) in order to learn the class and select the deserializer.
   Thus, the stream is pointing to the FIELD_NAME for the first field
   after the @@class. Thus, if you want your method to work correctly
   both with and without polymorphism, you must begin your method with:  
 @code

        if (p.getCurrentToken() == JsonToken.START_OBJECT) {
          p.nextToken();
        }  
  
@endcode
  This results in the stream pointing to the field name, so that
  the two conditions align. 
 <p>
  Post-condition is that the parser will point to the last
  event that is part of deserialized value (or in case deserialization
  fails, event that was not recognized or usable, which may be
  the same event as the one it pointed to upon call).
 <p>
  Note that this method is never called for JSON null literal,
  and thus deserializers need (and should) not check for it.
 @param p Parsed used for reading JSON content
 @param ctxt Context that can be used to access information about    this deserialization activity.
 @return Deserialized value
 */
- (id)deserializeWithComFasterxmlJacksonCoreJsonParser:(ComFasterxmlJacksonCoreJsonParser *)p
 withComFasterxmlJacksonDatabindDeserializationContext:(ComFasterxmlJacksonDatabindDeserializationContext *)ctxt;

/*!
 @brief Alternate deserialization method (compared to the most commonly
  used, <code>DeserializationContext)</code>),
  which takes in initialized value instance, to be
  configured and/or populated by deserializer.
 Method is not necessarily used (or supported) by all types
  (it will not work for immutable types, for obvious reasons):
  most commonly it is used for Collections and Maps.
  It may be used both with "updating readers" (for POJOs) and
  when Collections and Maps use "getter as setter".
 <p>
  Default implementation just throws 
 <code>UnsupportedOperationException</code>, to indicate that types
  that do not explicitly add support do not necessarily support
  update-existing-value operation (esp. immutable types)
 */
- (id)deserializeWithComFasterxmlJacksonCoreJsonParser:(ComFasterxmlJacksonCoreJsonParser *)p
 withComFasterxmlJacksonDatabindDeserializationContext:(ComFasterxmlJacksonDatabindDeserializationContext *)ctxt
                                                withId:(id)intoValue;

/*!
 @brief Deserialization called when type being deserialized is defined to
  contain additional type identifier, to allow for correctly
  instantiating correct subtype.This can be due to annotation on
  type (or its supertype), or due to global settings without
  annotations.
 <p>
  Default implementation may work for some types, but ideally subclasses
  should not rely on current default implementation.
  Implementation is mostly provided to avoid compilation errors with older
  code.
 @param typeDeserializer Deserializer to use for handling type information
 */
- (id)deserializeWithTypeWithComFasterxmlJacksonCoreJsonParser:(ComFasterxmlJacksonCoreJsonParser *)p
         withComFasterxmlJacksonDatabindDeserializationContext:(ComFasterxmlJacksonDatabindDeserializationContext *)ctxt
       withComFasterxmlJacksonDatabindJsontypeTypeDeserializer:(ComFasterxmlJacksonDatabindJsontypeTypeDeserializer *)typeDeserializer;

/*!
 @brief Method needed by <code>BeanDeserializerFactory</code> to properly link
  managed- and back-reference pairs.
 @since 2.2 (was moved out of <code>BeanDeserializerBase</code>)
 */
- (ComFasterxmlJacksonDatabindDeserSettableBeanProperty *)findBackReferenceWithNSString:(NSString *)refName;

/*!
 @brief Accessor that can be used to determine if this deserializer uses
  another deserializer for actual deserialization, by delegating
  calls.If so, will return immediate delegate (which itself may
  delegate to further deserializers); otherwise will return null.
 @return Deserializer this deserializer delegates calls to, if null;
    null otherwise.
 @since 2.1
 */
- (ComFasterxmlJacksonDatabindJsonDeserializer *)getDelegatee;

/*!
 @brief This method may be called in conjunction with calls to 
 <code>getEmptyValue(DeserializationContext)</code>, to check whether it needs
  to be called just once (static values), or each time empty value is
  needed.
 @since 2.9
 */
- (ComFasterxmlJacksonDatabindUtilAccessPattern *)getEmptyAccessPattern;

/*!
 */
- (id)getEmptyValue;

/*!
 @brief Method called to determine value to be used for "empty" values
  (most commonly when deserializing from empty JSON Strings).
 Usually this is same as <code>getNullValue</code> (which in turn
  is usually simply Java null), but it can be overridden
  for types. Or, if type should never be converted from empty
  String, method can also throw an exception.
 <p>
  Since version 2.6 (in which the context argument was added), call is
  expected to be made each and every time an empty value is needed.
 <p>
  Since version 2.9 does not require return of `T` any more.
 <p>
  Default implementation simply calls <code>getNullValue</code> and
  returns value.
 @since 2.6 Added to replace earlier no-arguments variant
 */
- (id)getEmptyValueWithComFasterxmlJacksonDatabindDeserializationContext:(ComFasterxmlJacksonDatabindDeserializationContext *)ctxt;

/*!
 @brief Method that will
  either return null to indicate that type being deserializers
  has no concept of properties; or a collection of identifiers
  for which <code>toString</code> will give external property
  name.
 This is only to be used for error reporting and diagnostics
  purposes (most commonly, to accompany "unknown property"
  exception).
 @since 2.0
 */
- (id<JavaUtilCollection>)getKnownPropertyNames;

/*!
 @brief Default implementation indicates that "null value" to use for input null
  is simply Java `null` for all deserializers, unless overridden by sub-classes.
 This information may be used as optimization.
 */
- (ComFasterxmlJacksonDatabindUtilAccessPattern *)getNullAccessPattern;

/*!
 */
- (id)getNullValue;

/*!
 @brief Method that can be called to determine value to be used for
  representing null values (values deserialized when JSON token
  is <code>JsonToken.VALUE_NULL</code>).Usually this is simply
  Java null, but for some types (especially primitives) it may be
  necessary to use non-null values.
 <p>
  Since version 2.6 (in which the context argument was added), call is
  expected to be made each and every time a null token needs to
  be handled.
 <p>
  Default implementation simply returns null.
 @since 2.6 Added to replace earlier no-arguments variant
 */
- (id)getNullValueWithComFasterxmlJacksonDatabindDeserializationContext:(ComFasterxmlJacksonDatabindDeserializationContext *)ctxt;

/*!
 @brief Accessor that can be used to check whether this deserializer
  is expecting to possibly get an Object Identifier value instead of full value
  serialization, and if so, should be able to resolve it to actual
  Object instance to return as deserialized value.
 <p>
  Default implementation returns null, as support cannot be implemented
  generically. Some standard deserializers (most notably 
 <code>com.fasterxml.jackson.databind.deser.BeanDeserializer</code>)
  do implement this feature, and may return reader instance, depending on exact
  configuration of instance (which is based on type, and referring property).
 @return ObjectIdReader used for resolving possible Object Identifier
     value, instead of full value serialization, if deserializer can do that;
     null if no Object Id is expected.
 @since 2.0
 */
- (ComFasterxmlJacksonDatabindDeserImplObjectIdReader *)getObjectIdReader;

/*!
 @brief Method for accessing type of values this deserializer produces.
 Note that this information is not guaranteed to be exact -- it
  may be a more generic (super-type) -- but it should not be
  incorrect (return a non-related type).
 <p>
  Default implementation will return null, which means almost same
  same as returning <code>Object.class</code> would; that is, that
  nothing is known about handled type.
 <p>
 @since 2.3
 */
- (IOSClass *)handledType;

/*!
 @brief Method called to see if deserializer instance is cachable and
  usable for other properties of same type (type for which instance
  was created).
 <p>
  Note that cached instances are still resolved on per-property basis,
  if instance implements <code>com.fasterxml.jackson.databind.deser.ResolvableDeserializer</code>:
  cached instance is just as the base. This means that in most cases it is safe to
  cache instances; however, it only makes sense to cache instances
  if instantiation is expensive, or if instances are heavy-weight.
 <p>
  Default implementation returns false, to indicate that no caching
  is done.
 */
- (jboolean)isCachable;

/*!
 @brief Method that can be called to try to replace deserializer this deserializer
  delegates calls to.If not supported (either this deserializer does not
  delegate anything; or it does not want any changes), should either
  throw <code>UnsupportedOperationException</code> (if operation does not
  make sense or is not allowed); or return this deserializer as is.
 @since 2.1
 */
- (ComFasterxmlJacksonDatabindJsonDeserializer *)replaceDelegateeWithComFasterxmlJacksonDatabindJsonDeserializer:(ComFasterxmlJacksonDatabindJsonDeserializer *)delegatee;

/*!
 @brief Introspection method that may be called to see whether deserializer supports
  update of an existing value (aka "merging") or not.Return value should either
  be <code>Boolean.FALSE</code> if update is not supported at all (immutable values); 
 <code>Boolean.TRUE</code> if update should usually work (regular POJOs, for example),
  or <code>null</code> if this is either not known, or may sometimes work.
 <p>
  Information gathered is typically used to either prevent merging update for
  property (either by skipping, if based on global defaults; or by exception during
  deserialization construction if explicit attempt made) if <code>Boolean.FALSE</code>
  returned, or inclusion if <code>Boolean.TRUE</code> is specified. If "unknown" case
  (<code>null</code> returned) behavior is to exclude property if global defaults
  used; or to allow if explicit per-type or property merging is defined.
 <p>
  Default implementation returns <code>null</code> to allow explicit per-type
  or per-property attempts.
 @since 2.9
 */
- (JavaLangBoolean *)supportsUpdateWithComFasterxmlJacksonDatabindDeserializationConfig:(ComFasterxmlJacksonDatabindDeserializationConfig *)config;

/*!
 @brief Method that will return deserializer instance that is able
  to handle "unwrapped" value instances
  If no unwrapped instance can be constructed, will simply
  return this object as-is.
 <p>
  Default implementation just returns 'this'
  indicating that no unwrapped variant exists
 */
- (ComFasterxmlJacksonDatabindJsonDeserializer *)unwrappingDeserializerWithComFasterxmlJacksonDatabindUtilNameTransformer:(ComFasterxmlJacksonDatabindUtilNameTransformer *)unwrapper;

@end

J2OBJC_EMPTY_STATIC_INIT(ComFasterxmlJacksonDatabindJsonDeserializer)

FOUNDATION_EXPORT void ComFasterxmlJacksonDatabindJsonDeserializer_init(ComFasterxmlJacksonDatabindJsonDeserializer *self);

J2OBJC_TYPE_LITERAL_HEADER(ComFasterxmlJacksonDatabindJsonDeserializer)

#endif

#if !defined (ComFasterxmlJacksonDatabindJsonDeserializer_None_) && (INCLUDE_ALL_ComFasterxmlJacksonDatabindJsonDeserializer || defined(INCLUDE_ComFasterxmlJacksonDatabindJsonDeserializer_None))
#define ComFasterxmlJacksonDatabindJsonDeserializer_None_

/*!
 @brief This marker class is only to be used with annotations, to
  indicate that <b>no deserializer is configured</b>.
 <p>
  Specifically, this class is to be used as the marker for
  annotation <code>com.fasterxml.jackson.databind.annotation.JsonDeserialize</code>
 */
@interface ComFasterxmlJacksonDatabindJsonDeserializer_None : ComFasterxmlJacksonDatabindJsonDeserializer

@end

J2OBJC_EMPTY_STATIC_INIT(ComFasterxmlJacksonDatabindJsonDeserializer_None)

J2OBJC_TYPE_LITERAL_HEADER(ComFasterxmlJacksonDatabindJsonDeserializer_None)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_ComFasterxmlJacksonDatabindJsonDeserializer")
